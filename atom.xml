<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WINGO&#39;S BLOG</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-08T08:16:45.477Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wingo Wen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2022/04/07/Docker/"/>
    <id>http://example.com/2022/04/07/Docker/</id>
    <published>2022-04-07T08:45:18.000Z</published>
    <updated>2022-04-08T08:16:45.477Z</updated>
    
    <content type="html"><![CDATA[<p>以下 docker-compose 的版本若未特殊说明，皆为 3.0。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认创 bridge 网络</span></span><br><span class="line">docker network create default_network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络内部信息</span></span><br><span class="line">docker network inspect default_network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除指定的网络</span></span><br><span class="line">docker network rm default_network</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">self-define-network</span></span><br></pre></td></tr></table></figure><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>Docker 的容器资源限制，CPU 按百分比进行限制，使用 <code>docker stats [container]</code> 查看容器的 CPU 使用率，此使用率显示的是占用宿主机的百分比。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU 打满的脚本</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">openssl speed;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line"><span class="attr">cpus:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">memory:</span> <span class="string">16G</span></span><br></pre></td></tr></table></figure><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d [image] /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下 docker-compose 的版本若未特殊说明，皆为 3.0。&lt;/p&gt;
&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;figure class=&quot;highlight shell</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spark</title>
    <link href="http://example.com/2022/04/06/Spark/"/>
    <id>http://example.com/2022/04/06/Spark/</id>
    <published>2022-04-06T10:23:01.000Z</published>
    <updated>2022-04-08T21:49:34.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>一个较为广泛的定义是：Spark 是一个类 Hadoop MapReduce 的通用并行框架，专为大规模数据处理而设计的快速通用的大数据引擎及轻量级的大数据处理统一平台。</p><p>发展到现在，Spark 这个词已经不仅仅只代表 Spark 了，也代表着 Spark 生态。</p><ul><li>Spark SQL 提供 HiveQL ( Apache Hive 的 SQL 变体，Hive 查询语言 ) 与 Spark 进行交互的 API；每个数据库表被当做一个 RDD，Spark SQL 被转换为 Spark 操作。</li><li>Spark Steaming 对实时数据流进行处理和控制，允许程序能够像处理普通 RDD 数据一样处理实时数据。</li></ul><p><strong>MapReduce VS. Spark：</strong></p><p>MapReduce 只提供 Map 和 Reduce 两个操作，复杂的计算需要大量的 Job 才能完成；其中间结果放置在 HDFS 文件系统中，迭代计算的效率很低；适用 Batch 数据处理，对交互式、实时数据处理支持不够；开发需要写大量的底层代码。</p><p>Spark 提供了丰富的算子；中间结果存储在内存中。</p><p>由于 MapReduce 每一步操作的结果都会被存入磁盘中，故在计算出现错时可以很好的从磁盘中恢复；Spark 则需要根据 RDD 中的信息进行数据的重新计算，会耗费一定的资源。</p><p>Spark 故障恢复的两种方式：</p><ul><li>通过数据的血缘关系再执行一遍前面的处理。</li><li>Checkpoint 将数据存储到持久化储存中。</li></ul><p><strong>Spark 运行方式：</strong></p><p>在 Spark 集群中由一个节点作为 driver 端创建 SparkContext。Spark 应用程序的入口负责调度各个运算资源，协调各个 WorkerNode上 的 Executor。根据用户输入的参数会产生若干个 worker，worker 节点运行若干个 executor，一个 executor 是一个进程，运行各自的 task，<strong>每个 task 执行相同的代码段处理不同的数据</strong>。</p><p>DAG Scheduler 划分作业，依次提交 stage 对应的 taskSet 给 task 作业调度器 TaskScheduleImpl，Task 作业调度器 submite taskSet 给 driver 端的 CoarseGrainedExecutorBackend ( 与 Executor 通信的 )，CoarseGrainedExecutorBackend 接收到 task 提交 even 后，会调用 Executor 执行 task，最终 task 是在 TaskRunner 的 run 方法内运行。</p><p>Spark 根据 RDD 之间的不同点依赖关系切分成不同的阶段（Stage）；没有依赖关系的 Stage 是可以并行执行的，但是对于 job，Spark是串行执行的，如果想要并行执行 Job，可以在 Spark 程序中进行多线程编程。</p><p>在这个 DAG 图中，Spark 能够充分了解数据之间的血缘关系，这样某些任务失败后可以根据血缘关系重新执行计算获取失败了的 RDD。</p><p><strong>宽依赖和窄依赖</strong></p><p>窄依赖指父 RDD 的每个分区只被子 RDD 的一个分区所使用。</p><p>宽依赖指父 RDD 的每个分区可能被多个子 RDD 的分区所使用。</p><p><strong>Spark 的资源管理架构：</strong></p><p>Master 是 Spark 的 主控节点，在实际的生产环境中会有多个 Master，只有一个 Master 处于 active 状态。</p><p>Worker 是 Spark 的工作节点，向 Master 汇报自身的资源、Executor 执行状态的改变，并接受 Master 的命令启动 Executor 或 Driver。</p><p>Driver 是应用程序的驱动程序，每个应用包括许多小任务，Driver 负责推动这些小任务的有序执行。</p><p>Executor 是 Spark 的工作进程，由 Worker 监管，负责具体任务的执行。</p><p>在 Spark 和 Yarn 两边的角色对比中：Master 和 ResourceManager 对应，Worker 和 NodeManager 对应，Driver 和 AppMaster 对应，Executor 和 Container 对应。架构相似，因此 Spark 很容易构建在 Yarn 之上。</p><p><strong>部署模式：</strong></p><ul><li><strong>Local 模式</strong>：部署在同一个进程上，只有 Driver 角色。接受任务后创建 Driver 负责应用的调度执行，不涉及 Master 和 Worker；</li><li><strong>Local-Cluster 模式</strong>：部署在同一个进程上，存在 Master 和 Worker 角色，它们作为独立线程存在于这个进程内；</li><li><strong>Standalone 模式</strong>：Spark 真正的集群模式，在这个模式下 Master 和 Worker 是独立的进程；</li><li><strong>第三方部署模式</strong>：构建于 Yarn 或 Mesos 之上，由它们提供资源管理。</li></ul><h2 id="Spark-on-Yarn"><a href="#Spark-on-Yarn" class="headerlink" title="Spark on Yarn"></a>Spark on Yarn</h2><p><strong>Spark on Yarn 对 Job 的处理过程：</strong></p><p>客户端提交一个任务给 Yarn ResourceManager 后，AppManager 接受任务并找到一个 Container 创建 AppMaster，此时 AppMaster 上运行的是 Spark Driver。之后 AppMaster 申请 Container 并启动，Spark Driver 在 Container 上启动 Spark Executor，并调度 Spark Task 在 Spark Executor 上运行，等到所有的任务执行完毕后，向 AppManager 取消注册并释放资源。</p><p><strong>Spark on Yarn-Client：</strong> </p><p>客户端在提交完任务之后不会将 Spark Driver 托管给 Yarn，而是在客户端运行。AppMaster 申请完 Container 之后同样也是由 Spark Driver 去启动 Spark Executor，执行任务。</p><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p>Yarn，Yet Another Resource Negotiator，是一个工作调度集群资源管理框架。</p><p>在 Yarn 问世前，Hadoop 使用 JobTracker 进行资源管理和作业调度。存在以下瓶颈：JobTracker 同时部署多个时只有一个是处于 active 状态；应用程序相关和资源管理相关的逻辑全部放在 JobTracker 中；MapReduce 计算模型与 JobTracker 的耦合过高。</p><p>Yarn 采用 Master &#x2F; Slave 结构，整体采用双层调度架构：第一层调度是 ResourceManager 和 NodeManager。</p><ul><li>ResourceManager 包含 Scheduler 和 AppManager 两个组件，分管资源调度和应用管理。（进行拆分，粒度比 JobTracker 更细）</li><li>NodeManager 可部署在独立机器上，用于管理机器上的资源。</li></ul><p>第二层调度指的是 NodeManager 和 Container，NodeManger 会将资源抽象成一个个 Container 并管理它们的生命周期。</p><p><strong>Yarn 运作流程：</strong></p><ol><li>客户端向 ResourceManager 的 AppManager 提交应用并请求一个 AppMaster 实例；</li><li>ResourceManager 找到可以运行一个 Container 的 NodeManager，并在这个 Container 中启动 AppMaster 实例；</li><li>AppMaster 向 ResourceManager 注册，注册之后，客户端就可以查询 ResourceManager 获得自己 AppMaster 的详情以及直接和 App Master 交互；</li><li>接着 AppMaster 向 Resource Manager 请求资源，即 Container；</li><li>获得 Container 后，AppMaster 启动 Container，并执行 Task；</li><li>Container 执行过程中会把运行进度和状态等信息发送给 AppMaster；</li><li>客户端主动和 App Master 交流应用的运行状态、进度更新等信息；</li><li>所有工作完成 App Master 向 RM 取消注册然后关闭，同时所有的 Container 也归还给系统。</li></ol><p>从以上流程可以了解到，AppMaster 是作为 Job 的驱动角色，它驱动了 Job 任务的调度执行。在这个运作流程中，AppManager 只需要管理 AppMaster 的生命周期以及保存它的内部状态，而 AppMaster 这个角色的抽象使得每种类型的应用都可以定制自己的 AppMaster，这样其他的计算模型就可以相对容易地运行在 Yarn 集群上。</p><h2 id="Yarn-HA"><a href="#Yarn-HA" class="headerlink" title="Yarn HA"></a>Yarn HA</h2><p>假如 Container 故障 Resource Manager 可以分配其他的 Container 继续执行，当运行 AppMaster 的 Container 故障后也将分配新的 Container，AppMaster 可以从 AppManager 获取信息恢复。当 NodeManager 故障的时候系统可以先把这个节点移除，在其他 NodeManager 重启再继续任务。</p><p>ResourceManager 可以启动多台，只有其中一台是 active 状态的，其他都处于待命状态。这台 active 状态的 ResourceManager 执行的时候会向 ZooKeeper 集群写入它的状态，当它故障的时候这些 RM 首先选举出另外一台正常运行的 RM 变为 active 状态，然后从 ZooKeeper 集群加载出现故障 ResourceManager 的状态。在转移的过程中它不接收新的 Job，转移完成后才接收新 Job。</p><h2 id="资源分配方式"><a href="#资源分配方式" class="headerlink" title="资源分配方式"></a>资源分配方式</h2><p><strong>FIFO Scheduler</strong></p><p>如果没有配置策略的话，所有的任务都提交到一个 default 队列，根据它们的提交顺序执行。富裕资源就执行任务，若资源不富裕就等待前面的任务执行完毕后释放资源，这就是 FIFO Scheduler 先入先出的分配方式。</p><p>在  Job1 提交时占用了所有的资源，不久后 Job2 提交了，但是此时系统中已经没有资源可以分配给它了。加入 Job1 是一个大任务，那么 Job2 就只能等待一段很长的时间才能获得执行的资源。所以先入先出的分配方式存在一个问题就是大任务会占用很多资源，造成后面的小任务等待时间太长而饿死，因此一般不使用这个默认配置。</p><p><strong>Capacity Scheduler</strong></p><p>Capacity Scheduler 是一种多租户、弹性的分配方式。每个租户一个队列，每个队列可以配置能使用的资源上限与下限（譬如 50%，达到这个上限后即使其他的资源空置着，也不可使用），通过配置可以令队列至少有资源下限配置的资源可使用。</p><p><img src="https://pic3.zhimg.com/v2-16e61b7b9a38b83d81f1eff0b57eb4be_b.jpg" alt="img"></p><p>队列 A 和队列 B 分配了相互独立的资源。Job1 提交给队列 A 执行，它只能使用队列 A 的资源。接着 Job2 提交给了队列 B 就不必等待 Job1 释放资源了。这样就可以将大任务和小任务分配在两个队列中，这两个队列的资源相互独立，就不会造成小任务饿死的情况了。</p><p><strong>Fair Scheduler</strong></p><p>Fair Scheduler 是一种公平的分配方式，所谓的公平就是集群会尽可能地按配置的比例分配资源给队列。</p><p>Job1 提交给队列 A，它占用了集群的所有资源。接着 Job2 提交给了队列 B，这时 Job1 就需要释放它的一半的资源给队列 A 中的 Job2 使用。接着 Job3 也提交给了队列 B，这个时候 Job2 如果还未执行完毕的话也必须释放一半的资源给 Job3。这就是公平的分配方式，在队列范围内所有任务享用到的资源都是均分的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spark&quot;&gt;&lt;a href=&quot;#Spark&quot; class=&quot;headerlink&quot; title=&quot;Spark&quot;&gt;&lt;/a&gt;Spark&lt;/h1&gt;&lt;p&gt;一个较为广泛的定义是：Spark 是一个类 Hadoop MapReduce 的通用并行框架，专为大规模数据处理而设</summary>
      
    
    
    
    
    <category term="Big Data" scheme="http://example.com/tags/Big-Data/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 必知必会</title>
    <link href="http://example.com/2022/04/06/MySQL%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://example.com/2022/04/06/MySQL%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2022-04-06T09:07:16.000Z</published>
    <updated>2022-04-06T09:29:04.459Z</updated>
    
    
    
    
    
    <category term="Database" scheme="http://example.com/tags/Database/"/>
    
  </entry>
  
</feed>
